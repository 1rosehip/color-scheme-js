// Generated by CoffeeScript 1.6.1
(function() {
  var ColorScheme, sprintf, _;

  _ = require('lodash');

  sprintf = require('sprintf').sprintf;

  ColorScheme = (function() {
    var splitwords, word, _i, _len, _ref;

    splitwords = function(words) {
      return words.split(/\s+/);
    };

    ColorScheme.SCHEMES = {};

    _ref = "mono monochromatic contrast triade tetrade analogic".split(/\s+/);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      word = _ref[_i];
      ColorScheme.SCHEMES[word] = true;
    }

    ColorScheme.PRESETS = {
      "default": [-1, -1, 1, -0.7, 0.25, 1, 0.5, 1],
      pastel: [0.5, -0.9, 0.5, 0.5, 0.1, 0.9, 0.75, 0.75],
      soft: [0.3, -0.8, 0.3, 0.5, 0.1, 0.9, 0.5, 0.75],
      light: [0.25, 1, 0.5, 0.75, 0.1, 1, 0.5, 1],
      hard: [1, -1, 1, -0.6, 0.1, 1, 0.6, 1],
      pale: [0.1, -0.85, 0.1, 0.5, 0.1, 1, 0.1, 0.75]
    };

    ColorScheme.COLOR_WHEEL = {
      0: [255, 0, 0, 100],
      15: [255, 51, 0, 100],
      30: [255, 102, 0, 100],
      45: [255, 128, 0, 100],
      60: [255, 153, 0, 100],
      75: [255, 178, 0, 100],
      90: [255, 204, 0, 100],
      105: [255, 229, 0, 100],
      120: [255, 255, 0, 100],
      135: [204, 255, 0, 100],
      150: [153, 255, 0, 100],
      165: [51, 255, 0, 100],
      180: [0, 204, 0, 80],
      195: [0, 178, 102, 70],
      210: [0, 153, 153, 60],
      225: [0, 102, 178, 70],
      240: [0, 51, 204, 80],
      255: [25, 25, 178, 70],
      270: [51, 0, 153, 60],
      285: [64, 0, 153, 60],
      300: [102, 0, 153, 60],
      315: [153, 0, 153, 60],
      330: [204, 0, 153, 80],
      345: [229, 0, 102, 90]
    };

    function ColorScheme() {}

    ColorScheme.mutablecolor = (function() {

      mutablecolor.prototype.hue = 0;

      mutablecolor.prototype.saturation = [];

      mutablecolor.prototype.value = [];

      mutablecolor.prototype.base_red = 0;

      mutablecolor.prototype.base_green = 0;

      mutablecolor.prototype.base_saturation = 0;

      mutablecolor.prototype.base_value = 0;

      function mutablecolor(hue) {
        this.hue = hue;
        if (this.hue == null) {
          throw "No hue specified";
        }
      }

      mutablecolor.prototype.set_hue = function(h) {
        var avrg, colorset1, colorset2, d, derivative1, derivative2, en, k;
        avrg = function(a, b, k) {
          return a + Math.round((b - a) * k);
        };
        this.hue = Math.round(h % 360);
        d = this.hue % 15 + (this.hue - Math.floor(this.hue));
        k = d / 15;
        derivative1 = this.hue - Math.floor(d);
        derivative2 = (derivative1 + 15) % 360;
        colorset1 = COLOR_WHEEL[derivative1];
        colorset2 = COLOR_WHEEL[derivative2];
        en = {
          red: 0,
          green: 1,
          blue: 2,
          value: 3
        };
        _.each(en, function(i, color) {
          return this["base_" + color] = avrg(colorset1[i], colorset2[i], k);
        });
        this.base_saturation = avrg(100, 100, k) / 100;
        return this.base_value /= 100;
      };

      mutablecolor.prototype.rotate = function(angle) {
        var newhue;
        newhue = (this.hue + angle) % 360;
        return this.set_hue(newhue);
      };

      mutablecolor.prototype.get_saturation = function(variation) {
        var s, x;
        x = this.saturation[variation];
        s = x < 0 ? -x * this.base_saturation : x;
        if (s > 1) {
          s = 1;
        }
        if (s < 0) {
          s = 0;
        }
        return s;
      };

      mutablecolor.prototype.get_value = function(variation) {
        var v, x;
        x = this.value[variation];
        v = x < 0 ? -x * this.base_value : x;
        if (v > 1) {
          v = 1;
        }
        if (v < 0) {
          v = 0;
        }
        return v;
      };

      mutablecolor.prototype.set_variant = function(variation, s, v) {
        this.saturation[variation] = s;
        return this.value[variation] = v;
      };

      mutablecolor.prototype.set_variant_preset = function(p) {
        var i, _j, _results;
        _results = [];
        for (i = _j = 0; _j <= 3; i = ++_j) {
          _results.push(this.set_variant(i, p[2 * i], p[2 * i + 1]));
        }
        return _results;
      };

      mutablecolor.prototype.get_hex = function(web_safe, variation) {
        var color, format, k, max, min, rgb, s, v, _j, _ref1;
        max = _.max((function() {
          var _j, _len1, _ref1, _results;
          _ref1 = ['red', 'green', 'blue'];
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            color = _ref1[_j];
            _results.push(this["base_" + color]);
          }
          return _results;
        }).call(this));
        min = _.min((function() {
          var _j, _len1, _ref1, _results;
          _ref1 = ['red', 'green', 'blue'];
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            color = _ref1[_j];
            _results.push(this["base_" + color]);
          }
          return _results;
        }).call(this));
        v = (variation < 0 ? this.base_value : this.get_value(variation)) * 255;
        s = variation < 0 ? this.base_saturation : this.get_saturation(variation);
        k = max > 0 ? v / max : 0;
        rgb = _.map(['red', 'green', 'blue'], function(color) {
          return _.min(255, Math.round(v - (v - this["base_" + color] * k) * s));
        });
        if (web_safe) {
          rgb = _.map(rgb, function(c) {
            return Math.round(c / 51) * 51;
          });
        }
        format = "";
        for (_j = 1, _ref1 = rgb.length; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; 1 <= _ref1 ? _j++ : _j--) {
          format += '%02x';
        }
        return sprintf(format, rgb);
      };

      return mutablecolor;

    })();

    return ColorScheme;

  })();

  module.exports = ColorScheme;

}).call(this);
